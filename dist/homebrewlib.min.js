(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.homebrewlib = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {

  // Amount of water (liters) absorbed by 1 kg of grain (average, emprical value)
  // Source: https://byo.com/bock/item/410-calculating-water-usage-advanced-brewing
  grain_absorption : 1.04,

  // Volume in l occupied by 1 kg of grains
  // Source: https://byo.com/bock/item/410-calculating-water-usage-advanced-brewing
  grain_volume : 0.67,

  // CO2 produced by fermenting sugar (percentage of weight)
  // source: http://braukaiser.com/wiki/index.php?title=Accurately_Calculating_Sugar_Additions_for_Carbonation
  sucrose_to_CO2_conversion  : 0.51,
  dextrose_to_CO2_conversion : 0.51 * 0.91,
  extract_to_CO2_conversion  : 0.51 * 0.82 * 0.80,

  // Color adjustment in EBC during wort production
  // source:
  color_adjustment : 3

};

},{}],2:[function(require,module,exports){
module.exports = {

  // temperature from Celsius to Fahrenheit
  // example: 0˚C >> 32F
  c2f : function (temp) {
    return temp * 9/5 + 32;
  },

  // temperature from Fahrenheit to Celsius
  // example: 32F >> 0˚C
  f2c : function (temp) {
    return (temp - 32) * 5/9;
  },

  // volume from gallons to liters
  // example: 5 gal >> 7,57 l
  gal2l : function (vol) {
    return vol * 3.78541;
  },

  // volume from liters to gallons
  // example: 10 l >> 2,64 gal
  l2gal : function (vol) {
    return vol / 3.78541;
  },

  // ounces to grams
  // example: 1 oz >> 28.35 g
  oz2g : function (qty) {
    return qty * 28.3495;
  },

  // grams to ounces
  // example: 50 g >> 1.76 oz
  g2oz : function (qty) {
    return qty / 28.3495;
  },

  // pound to kg
  // example: 5 lbs >> 2.27 kg
  lbs2kg : function (qty) {
    return qty * 0.453592;
  },

  // kg to pound
  // example: 10 kg >> 22.05 lbs
  kg2lbs : function (qty) {
    return qty / 0.453592;
  },

  // specific gravity to degrees Plato
  // source: https://www.brewersfriend.com/plato-to-sg-conversion-chart/
  // example: 1.050 SG >> 12.4˚P
  sg2p : function (sg) {
    //return -205.347*sg*sg + 668.72*sg - 463.37;
    return -616.868 + 1111.14*sg - 630.272*sg*sg + 135.997*sg*sg*sg;
  },

  // degrees Plato to specific gravity
  // source: https://www.brewersfriend.com/plato-to-sg-conversion-chart/
  // example: 15˚P >> 1.061 SG
  p2sg : function (p) {
    return 1 + p / (258.6 - p/258.2*227.1);
  },

  // transform Brix values of non fermented wort, given the refractometer's correction factor
  // source: https://byo.com/malt/item/1313-refractometers
  obrix2sg : function (obrix, correction) {
    var brix = obrix / correction;
    return 1.000019 + 0.003865613*brix + 0.00001296425*brix*brix + 0.00000005701128*brix*brix*brix;  // CHECK POWERS!!!
  },

  // transform Brix values of fermenting/fermented wort
  // source: http://digitaleditions.walsworthprintgroup.com/publication/frame.php?i=415999&p=1&pn=&ver=html5
  fbrix2sg : function (fbrix, correction, obrix) {
    return 1 - 0.002349*obrix/correction + 0.006276*fbrix/correction;
  },

  // calculate ABW from Brix readings
  // source: http://digitaleditions.walsworthprintgroup.com/publication/frame.php?i=415999&p=1&pn=&ver=html5
  get_ABW : function (obrix, fbrix, correction) {
    return 0.67062*obrix / correction - 0.66091*fbrix/correction;
  },

  // calculate ABV from SG and ABW
  // source: http://digitaleditions.walsworthprintgroup.com/publication/frame.php?i=415999&p=1&pn=&ver=html5
  ABW2ABV : function (sg, abw) {
    return sg * abw / 0.791;
  }

};


// transformations to be checked and published
/*      'og': function() {
      this.obrix = ((143.254*this.og*this.og*this.og - 648.670*this.og*this.og + 1125.805*this.og - 620.389)* this.refractometer.correction).toFixed(1); // approximation to be checked
      this.oplato = homebrewlib.sg2p(this.og).toFixed(1);
    },
    'oplato': function() {
      this.og = homebrewlib.p2sg(this.oplato).toFixed(3);
      this.obrix = ((143.254*this.og*this.og*this.og - 648.670*this.og*this.og + 1125.805*this.og - 620.389)* this.refractometer.correction).toFixed(1); // approximation to be checked
    }, */
/*      'fg': function() {
      this.fbrix = ((this.fg - 1 + 0.002349*this.obrix/this.refractometer.correction) / 0.006276 * this.refractometer.correction).toFixed(1);
      this.fplato = homebrewlib.sg2p(this.fg).toFixed(1);
    },
    'fplato': function() {
      this.fg = homebrewlib.p2sg(this.fplato).toFixed(3);
      this.fbrix = ((this.fg - 1 + 0.002349*this.obrix/this.refractometer.correction) / 0.006276 * this.refractometer.correction).toFixed(1);
    }, */

},{}],3:[function(require,module,exports){
// implementation of brewing activities

var constants = require('./constants.js');
var conv      = require('./conversions.js');

// calculates the fermentation attenuation from Plato readings
get_attenuation = function (oplato, fplato) {
  if (oplato != 0)
    return 100 - fplato / oplato * 100;
  return 0;
}

// calculates the IBUs for one hop addition according to Tinseth
// source: http://realbeer.com/hops/research.html
// example: hop addition with 5.0% AA, 50g, 60mins, 60l, 1.035 SG >> 31 IBUs
get_ibu = function (alpha, weight, minutes, volume, sg, form, usage) {

  var alpha_acids = alpha/100.0 * weight * 1000.0 / volume;
  var bigness_factor = 1.65 * Math.pow( 0.000125, sg-1.0 );
  var boil_time_factor = (1.0 - Math.exp(-0.04 * minutes))/4.15;
  var utilization = bigness_factor * boil_time_factor;

  var increment = 1.0;
  if (form === 'pellets') increment += 0.1;
  if (usage === "after hot break") increment += 0.1 // CHECK WHIRLPOOL HERE

  return alpha_acids * utilization * increment;
}


// dilutes wort with water
add_water = function (wort, water_addition) {

  var dilution_factor = wort.vol / (wort.vol + water_addition);

  wort.og   = 1.0 + (wort.og - 1.0) * dilution_factor;
  wort.fg   = 1.0 + (wort.fg - 1.0) * dilution_factor;
  wort.abv *= dilution_factor;
  wort.ebc *= dilution_factor;
  wort.ibu *= dilution_factor;
  wort.co2 *= dilution_factor;
  wort.vol += water_addition;
}


// sugar additions prior to priming and final fermentation
add_sugar = function (wort, quantity, type) {

  // pure sucrose has a correction factor of 1 (it's the reference)
  var correction = 1.0;
  // corrections for dextrose and dry malt extract (DME)
  // Source: https://www.brewersfriend.com/beer-priming-calculator/
  switch (type) {
    case 'dextrose'            : correction = 0.91;
    case 'dry malt extract'    : correction = 0.68;
  }

  var new_sugar = quantity * correction;
  var total_sugar = wort.vol * wort.og * conv.sg2p(wort.og)/100 + new_sugar;

  var a = 258.6;
  var b = 227.1/258.2;
  var extract_plato = ( -(a+b*total_sugar*100/wort.vol) +
                      Math.sqrt(Math.pow(a+b*total_sugar*100/wort.vol,2) +
                      4*a*(1-b)*total_sugar*100/wort.vol)) / (2-2*b);
  var sg = conv.p2sg(extract_plato);

  wort.og  = sg;
  wort.fg  = wort.fg;
  wort.abv = wort.abv;
  wort.ebc = wort.ebc;
  wort.ibu = wort.ibu;
  wort.co2 = wort.co2;
  wort.vol = wort.vol;
}



// calculates the properties of the wort in the mash tun, before lautering
// source: https://byo.com/hops/item/761-hitting-target-original-gravity-and-volume-advanced-homebrewing
mash = function (inflow, activity, equipment, outflow) {

  var ebc = 0.0;
  var total_grain_weigth = 0.0;

  for (var i = 0; i < activity.malts.length; i++) {
    total_grain_weigth += activity.malts[i].weight;
    ebc += activity.malts[i].ebc * activity.malts[i].weight;
  }
  ebc = ebc / total_grain_weigth; // CHECK HOW TO TAKE INTO ACCOUNT WORT VOLUME!!
  if (isNaN(ebc)) ebc = 0.0;

  var extract = total_grain_weigth * equipment.mash_efficiency_weight;

  var volume = inflow.vol + activity.water - total_grain_weigth * constants.grain_absorption;

  var a = 258.6;
  var b = 227.1 / 258.2;
  var eff = equipment.mash_efficiency_weight * 100;
  var extract_plato = ( -(a+b*eff*total_grain_weigth/volume) +
                      Math.sqrt(Math.pow(a+b*eff*total_grain_weigth/volume,2) +
                      4*a*(1-b)*eff*total_grain_weigth/volume)) / (2-2*b);
  var sg = conv.p2sg(extract_plato);
  if (isNaN(sg)) sg = 1.0;

  outflow.vol = volume - equipment.mash_loss;
  outflow.og  = sg;
  outflow.fg  = sg;
  outflow.abv = inflow.abv;
  outflow.ebc = inflow.ebc + ebc;
  outflow.ibu = inflow.ibu;
  outflow.co2 = inflow.co2;
};



/* IBU target_position

h = require('homebrewlib')
r = h.new()
r.add(h.model.boil)
r.process[0].vol = 10
r.process[1].time = 60
r.process[1].hops[0] = {name: 'a', alpha: 5.0, weight: 10, time: 60, form:'pellets', usage:'forward'}
r.process[1].hops[1] = {name: 'b', alpha: 9.0, weight: 15, time: 9, form:'pellets', usage:'after hot break'}
r.brew()
r.process[1].hops

*/


// boil wort
// supported ingredients: hops, water additions
// add a property ibu to the hops containing calculated ibus per hop addition
boil = function (inflow, activity, equipment, outflow) {

  // todo: calculate boil-off using boiling power not %
  // change of volume due to evaporation
  var post_boil_volume = inflow.vol - equipment.boil_evaporation_rate * activity.time/60;

  // specific gravity at end of boil
  var sg = 1 + (inflow.og - 1) * inflow.vol/post_boil_volume;

  // IBUs at end of boil
  var total_ibu = 0.0;
  for (var i=0; i<activity.hops.length; i++) {
    activity.hops[i].ibu = get_ibu (activity.hops[i].alpha, activity.hops[i].weight, activity.hops[i].time + activity.whirlpool,
      post_boil_volume, (inflow.og + sg)/2.0, activity.hops[i].form, activity.hops[i].usage);
    total_ibu += activity.hops[i].ibu;
  }

  outflow.vol = post_boil_volume - equipment.boil_loss;
  outflow.og  = sg;
  outflow.fg  = sg;
  outflow.abv = inflow.abv;
  outflow.ebc = inflow.ebc + constants.color_adjustment; // CHECK HOW TO TAKE INTO ACCOUNT WORT VOLUME!!
  outflow.ibu = inflow.ibu + total_ibu;
  outflow.co2 = inflow.co2;

  // water addition during boil
  add_water(outflow, activity.water);

  // sugar additions during boil
  add_sugar(outflow, activity.sucrose,  "sucrose");
  add_sugar(outflow, activity.dextrose, "dextrose");
  add_sugar(outflow, activity.dry_malt, "dry malt extract");

  // drop possible wort used for carbonation with speise
  outflow.vol -= activity.speise;
};



ferment = function (inflow, activity, equipment, outflow) {

  // sugar additions
  add_sugar(inflow, activity.sucrose,  "sucrose");
  add_sugar(inflow, activity.dextrose, "dextrose");
  add_sugar(inflow, activity.dry_malt, "dry malt extract");

  var original_extract = conv.sg2p(inflow.og);
  var final_extract = original_extract;
  if (activity.yeast.attenuation)
    final_extract -= original_extract * activity.yeast.attenuation/100;
  var fg = conv.p2sg(final_extract);

  var co2 = 1.013 * Math.pow(2.71828182845904, -10.73797+2617.25/(activity.max_temp+273.15)) * 10;

  // source: http://www.cotubrewing.com/homebrewing/alcohol-content-formula/
  var abv = (1.05/0.79) * ((inflow.og - fg) / fg) * 100;
  if (abv < 0) abv = 0.0;

  outflow.vol = inflow.vol - equipment.fermentation_loss;
  outflow.og  = inflow.og;
  outflow.fg  = fg;
  outflow.abv = inflow.abv + abv;
  outflow.ebc = inflow.ebc;
  outflow.ibu = inflow.ibu;
  outflow.co2 = co2;

  // water addition
  add_water(outflow, activity.water);
};


bottle = function (inflow, activity, equipment, outflow) {

  var prime_co2 = 0.0;
  var speise_volume = 0.0;
  var prime_abw = 0.0

  prime_co2 += activity.sucrose * constants.sucrose_to_CO2_conversion;
  prime_abw += activity.sucrose * (1 - constants.sucrose_to_CO2_conversion);

  prime_co2 += activity.dextrose * constants.dextrose_to_CO2_conversion;
  prime_abw += activity.dextrose * (1 - constants.dextrose_to_CO2_conversion);

  prime_co2 += activity.dry_malt * constants.extract_to_CO2_conversion;
  prime_abw += activity.dry_malt * (1 - constants.extract_to_CO2_conversion);

  speise_volume = activity.speise;
  prime_co2 += 0.5 * 0.82 * speise_volume * inflow.og * conv.sg2p(inflow.og)*10 *
             (inflow.og - inflow.fg) / (inflow.og -1) / (inflow.vol + speise_volume);

  var prime_abv = prime_abw / 0.794 / 10.0;

  outflow.vol = inflow.vol - equipment.bottling_loss + speise_volume;
  outflow.og  = inflow.og;
  outflow.fg  = inflow.fg;
  outflow.abv = inflow.abv + prime_abv;
  outflow.ebc = inflow.ebc;
  outflow.ibu = inflow.ibu;
  outflow.co2 = inflow.co2 + prime_co2;
};


// split flow into two: user-defined volume is moved to new recipe,
// the rest of the volume is kept in current recipe
split = function (inflow, activity, equipment, outflow) {

  // copy inflow to outflow
  outflow.og  = inflow.og;
  outflow.fg  = inflow.fg;
  outflow.abv = inflow.abv;
  outflow.ebc = inflow.ebc;
  outflow.ibu = inflow.ibu;
  outflow.co2 = inflow.co2;

  // calculate volume of flow after split
  if (activity.target_recipe.process)
    outflow.vol = inflow.vol - activity.vol; // source recipe
  else
    outflow.vol = activity.source_split.vol; // target recipe
}

// merges two flows
merge = function (inflow, activity, equipment, outflow) {

 if (activity.merge_flow.vol) { // source flow defined >> merge flows into target recipe
   var wort = inflow;
   var merge_wort = activity.merge_flow;

   outflow.vol = wort.vol + merge_wort.vol;
   outflow.og  = (wort.og * wort.vol + merge_wort.og * merge_wort.vol) / (wort.vol + merge_wort.vol);
   outflow.fg  = (wort.fg * wort.vol + merge_wort.fg * merge_wort.vol) / (wort.vol + merge_wort.vol);
   outflow.abv = (wort.abv * wort.vol + merge_wort.abv * merge_wort.vol) / (wort.vol + merge_wort.vol);
   outflow.ebc = (wort.ebc * wort.vol + merge_wort.ebc * merge_wort.vol) / (wort.vol + merge_wort.vol);
   outflow.ibu = (wort.ibu * wort.vol + merge_wort.ibu * merge_wort.vol) / (wort.vol + merge_wort.vol);
   outflow.co2 = (wort.co2 * wort.vol + merge_wort.co2 * merge_wort.vol) / (wort.vol + merge_wort.vol);
 }
 else { // source flow not defined >> empty outflow of source recipe
   outflow.vol = 0.0;
   outflow.og  = 1.0;
   outflow.fg  = 1.0;
   outflow.abv = 0.0;
   outflow.ebc = 0.0;
   outflow.ibu = 0.0;
   outflow.co2 = 0.0;
 }
};

module.exports = {
//  get_ibu : get_ibu,
  mash    : mash,
  boil    : boil,
  ferment : ferment,
  bottle  : bottle,
  split   : split,
  merge   : merge,
};

},{"./constants.js":1,"./conversions.js":2}],4:[function(require,module,exports){
// schemas of all inputs/output/equipment configurations

var logic = require("./logic.js");

module.exports = {

//// EQUIPMENT CONFIGURATION WITH DEFAULT VALUES (CAN BE OVERWRITTEN)

  // default brew equipment properties
  equipment : {
    name: "8 liter equipment",     // unique name of equipment configuration

    mash_max_volume : 12.0,        // volume of mash tun in l
    mash_efficiency_weight : 0.72, // average mash efficiency in function of malt weight
    mash_false_bottom_volume: 2.0, // volume of wort below the faucet in l
    mash_loss : 1.0,               // loss of wort after lautering in l

    sparge_max_volume : 8.0,       // volume of lauter tun in l

    boil_max_volume : 15.0,        // volume of boil kettle in l
    boil_evaporation_rate : 2.3,   // evaporation rate of kettle in l/h
    boil_loss : 0.5,               // loss of wort after boiling in l

    whirlpool_loss : 0.0,          // loss of wort in whirlpool

    fermentation_max_volume: 12.0, // volume of fermentor in l
    fermentation_loss: 0.5,        // beer lost in fermentor in l

    bottling_loss: 0.0,            // loss of beer during bottling in l
  },


//// CONFIGURATION OF MODELING ELEMENTS (FLOWS AND ACTIVITIES) WITH DEAULT VALUES
//// (CAN BE OVERWRITTEN)

  // structure of liquid flows between brew activities (water, wort, beer)
  flow : {
    vol  : 0.0, // volume in liters
    og   : 1.0, // original specific gravity in kg/l
    fg   : 1.0, // final specific gravity in kg/l
    abv  : 0.0, // alcohol by volume in %
    ebc  : 0.0, // European beer color
    ibu  : 0.0, // international bitter units
    co2  : 0.0  // CO2 content in g/l
  },

  // configuration of mash step
  mash : {
    name  : "Mash",     // name of activity
    run   : logic.mash, // name of function implementing activity
    malts : [],         // list of malts to be mashed, see internal model below
    water : 0.0,        // sparge water in l
  },

  // structure of malt additions
  malt : {
    name   : '',  // unique name of malt variety
    form   : "grain" | "dry extract" | "liquid extract", // form of delivery  // NOT YET TAKEN INTO ACCOUNT
    weight : 0.0, // weight in kg
    ebc    : 0.0  // EBC of malt
  },

  // configuration of boil step
  boil : {
    name : "Boil",
    run  : logic.boil,
    time      : 0.0, // boil time in minutes
    whirlpool : 0.0, // whirlpool time in minutes
    hops      : [],  // hop list with elements as defined below
    water     : 0.0, // water added during boiling in l
    sucrose   : 0.0, // sucrose (table sugar) additions during boiling in kg
    dextrose  : 0.0, // dextrose addition in kg
    dry_malt  : 0.0, // dry malt addition in kg
    speise    : 0.0, // volume of speise used for priming
  },

  // structure of hop additions
  hop : {
    name : '',       // unique name of hop variety
    form : 'pellet', // allowed values: 'pellets' | 'cones' | 'cryo'
    weight : 0.0,    // weight in g
    alpha : 0.0,     // alpha acid content in %
    time : 0,        // time of contact with wort
    usage: ''        // allowed values: 'forward' | 'after hot break' | 'whirlpool'
  },

  // configuration of fermentation step
  ferment : {
    name : "Ferment",
    run  : logic.ferment,
    temp     : 0.0, // primary fermentation temperature in °C
    max_temp : 0.0, // maximum fermentation temperature in °C
    yeast    : { name: '',           // unique name of yeast strain
                 type : '',          // possible values: 'liquid' | 'dry' | 'slurry'
                 attenuation : 0.0}, // attenation in % (typically between 70-85%)
    water    : 0.0, // water added during boiling in liters
    sucrose  : 0.0, // sugar addition during boiling in kg
    dextrose : 0.0, // dextrose addition in kg
    dry_malt : 0.0, // dry malt addition in kg
    hops     : [],  // dry hop list with elements as defined above
  },

  // configuration of priming and bottling step
  bottle : {
    name : "Bottle",
    run  : logic.bottle,
    loss  : 0.0,    // loss of beer during bottling
    sucrose  : 0.0, // sugar addition for priming in g/l
    dextrose : 0.0, // dextrose addition for priming in g/l
    dry_malt : 0.0, // sugar additions for priming in g/l
    speise   : 0.0, // speise (wort) addition for priming in l
  },


//// FLOW MANAGEMENT ACTIVITIES: SPLIT AND MERGE

  // configuration of wort split activities
  split : {
    name : "Split",
    run  : logic.split,
    target_recipe : {}, // target recipe of split (for source recipe)
    source_split  : {}, // source split of split action (for target recipe)
    vol    : 0.0        // volume in l transferred from source to target
  },

  // configuration of wort merge activities
  merge : {
    name : "Merge",
    run  : logic.merge,
    merge_flow : {}, // source flow to be merged
  },

};

},{"./logic.js":3}],5:[function(require,module,exports){
var cons=require("./constants.js");var conv=require("./conversions.js");var model=require("./model.js");function Recipe(){this.set_equipment=function(equipment){this.equipment=JSON.parse(JSON.stringify(equipment))};this.set_equipment(model.equipment);this.reset=function(){this.process=[];this.process[0]=JSON.parse(JSON.stringify(model.flow))};this.reset();this.add=function(activity,position){if(typeof position==="undefined")position=this.process.length;else if(position<-1||position>=this.process.length){console.log("Illegal position for current model.");return}this.process.splice(position,0,JSON.parse(JSON.stringify(activity)),JSON.parse(JSON.stringify(model.flow)));this.process[position].run=activity.run;return this};this.split=function(position,target_recipe){if(!target_recipe){console.log("No target recipe specified.");return}if(typeof position==="undefined"||position<0||position>=this.process.length){console.log("Illegal position of split in source recipe.");return}if(this.process[position].name){console.log("Source node to be split is not a flow node.");return}this.process.splice(position+1,0,JSON.parse(JSON.stringify(model.split)),JSON.parse(JSON.stringify(model.flow)));this.process[position+1].run=model.split.run;this.process[position+1].target_recipe=target_recipe;target_recipe.equipment=this.equipment;for(var i=0;i<=position;i++)target_recipe.process[i]=this.process[i];target_recipe.process.splice(position+1,0,JSON.parse(JSON.stringify(model.split)),JSON.parse(JSON.stringify(model.flow)));target_recipe.process[position+1].run=model.split.run;target_recipe.process[position+1].source_split=this.process[position+1];return this};this.merge=function(source_position,target_recipe,target_position){if(!target_recipe){console.log("No target recipe specified.");return}if(typeof source_position==="undefined"||source_position<0||source_position>=this.process.length){console.log("Illegal position of merge in source recipe.");return}if(typeof target_position==="undefined"||target_position<0||target_position>=target_recipe.process.length){console.log("Illegal position of merge in target recipe.");return}if(this.process[source_position].name){console.log("Source node to be merged is not a flow node.");return}if(target_recipe.process[target_position].name){console.log("Target node to be merged is not a flow node.");return}this.process.splice(source_position+1,0,JSON.parse(JSON.stringify(model.merge)),JSON.parse(JSON.stringify(model.flow)));this.process[source_position+1].run=model.merge.run;target_recipe.process.splice(target_position+1,0,JSON.parse(JSON.stringify(model.merge)),JSON.parse(JSON.stringify(model.flow)));target_recipe.process[target_position+1].run=model.merge.run;target_recipe.process[target_position+1].merge_flow=this.process[source_position];return this};this.delete=function(position){if(typeof position==="undefined"||position<0||position>=this.process.length){console.log("Illegal position for current recipe.");return}if(this.process[position].type!="activity"){console.log("Position must point an activity node.");return}this.process.splice(position,2)};this.init=function(buffer){buffer.push(this);this.process[0].status="ready";for(var i=1;i<this.process.length;i++){if(this.process[i].name&&this.process[i].name=="Split"&&this.process[i].target_recipe.process)this.process[i].target_recipe.init(buffer);if(!this.process[i].name)this.process[i].status="tbd"}};this.calculate=function(){for(var i=1;i<this.process.length;i++){if(this.process[i].name){if(this.process[i-1].status!="ready")break;if(this.process[i].name=="Merge"&&this.process[i].merge_flow.status&&this.process[i].merge_flow.status!="ready")break;this.process[i].run(this.process[i-1],this.process[i],this.equipment,this.process[i+1]);this.process[i+1].status="ready"}}if(i==this.process.length)return 1;return 0};this.brew=function(){var recipies=[];this.init(recipies);while(recipies.length>0)for(var i=0;i<recipies.length;i++)if(recipies[i].calculate()){recipies.splice(i,1);i--}};return this}module.exports={conv:conv,cons:cons,model:model,new:function(){return new Recipe}};
},{"./constants.js":1,"./conversions.js":2,"./model.js":4}]},{},[5])(5)
});